옮긴이의 말
서문
감사의 말
1부 자바와 친해지기
1장 자바 기술 시스템 소개
1.1 들어가며
1.2 자바 기술 시스템
1.3 자바의 과거와 현재
1.4 자바 가상 머신 제품군
1.5 자바 기술의 미래
1.6 실전: 내 손으로 빌드하는 JDK
1.7 마치며
2부 자동 메모리 관리
2장 자바 메모리 영역과 메모리 오버플로
2.1 들어가며
2.2 런타임 데이터 영역
2.3 핫스팟 가상 머신에서의 객체 들여다보기
2.4 실전: OutOfMemoryError 예외
2.5 마치며
3장 가비지 컬렉터와 메모리 할당 전략
3.1 들어가며
3.2 대상이 죽었는가?
3.3 가비지 컬렉션 알고리즘
3.4 핫스팟 알고리즘 상세 구현
3.5 클래식 가비지 컬렉터
3.6 저지연 가비지 컬렉터
3.7 적합한 가비지 컬렉터 선택하기
3.8 실전: 메모리 할당과 회수 전략
3.9 마치며
4장 가상 머신 성능 모니터링과 문제 해결 도구
4.1 들어가며
4.2 기본적인 문제 해결 도구
4.3 GUI 도구
4.4 핫스팟 가상 머신 플러그인과 도구
4.5 마치며
5장 최적화 사례 분석 및 실전
5.1 들어가며
5.2 사례 분석
5.3 실전: 이클립스 구동 시간 줄이기
5.4 마치며
3부 자동 메모리 관리
6장 클래스 파일 구조
6.1 들어가며
6.2 플랫폼 독립을 향한 초석
6.3 클래스 파일의 구조
6.4 바이트코드 명령어 소개
6.5 설계는 공개, 구현은 비공개
6.6 클래스 파일 구조의 진화
6.7 마치며
7장 클래스 로딩 메커니즘
7.1 들어가며
7.2 클래스 로딩 시점
7.3 클래스 로딩 처리 과정
7.4 클래스 로더
7.5 자바 모듈 시스템
7.6 마치며
8장 바이트코드 실행 엔진
8.1 들어가며
8.2 런타임 스택 프레임 구조
8.3 메서드 호출
8.4 동적 타입 언어 지원
8.5 스택 기반 바이트코드 해석 및 실행 엔진
8.6 마치며
9장 클래스 로딩과 실행 서브시스템, 사례와 실전
9.1 들어가며
9.2 사례 연구
9.3 실전: 원격 실행 기능 직접 구현하기
9.4 마치며
4부 컴파일과 최적화
10장 프런트엔드 컴파일과 최적화
10.1 들어가며
10.2 javac 컴파일러
10.3 자바 편의 문법의 재미난 점
10.4 실전: 플러그인 애너테이션 처리기 제작
10.5 마치며
11장 백엔드 컴파일과 최적화
11.1 들어가며
11.2 JIT 컴파일러
11.3 AOT 컴파일러
11.4 컴파일러 최적화 기법
11.5 실전: 그랄 컴파일러 깊이 이해하기
11.6 마치며
5부 효율적인 동시성
12장 자바 메모리 모델과 스레드
12.1 들어가며
12.2 하드웨어에서의 효율과 일관성
12.3 자바 메모리 모델
12.4 자바와 스레드
12.5 자바와 가상 스레드
12.6 마치며
13장 스레드 안전성과 락 최적화
13.1 들어가며
13.2 스레드 안전성
13.3 락 최적화
13.4 마치며
부록 약어 목록
찾아보기