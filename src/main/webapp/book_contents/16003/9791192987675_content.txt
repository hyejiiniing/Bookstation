옮긴이 머리말 xv
베타리더 후기 xviii
추천 서문(조시 롱) xx
머리말 xxii
감사의 글 xxiv
이 책에 대하여 xxvi
표지에 대하여 xxxii

PART I 클라우드 네이티브 개요
CHAPTER 1 클라우드 네이티브 소개 3
1.1 클라우드 네이티브란 무엇인가? 5
__1.1.1 클라우드 네이티브에서의 세 가지 P 5
1.2 클라우드와 클라우드 컴퓨팅 모델 6
__1.2.1 서비스형 인프라스트럭처 9 / 1.2.2 서비스형 컨테이너 9 / 1.2.3 서비스형 플랫폼 10 / 1.2.4 서비스형 함수 10 / 1.2.5 서비스형 소프트웨어 11
1.3 클라우드 네이티브 애플리케이션의 특성 11
__1.3.1 확장성 12 / 1.3.2 느슨한 결합 13 / 1.3.3 복원력 15 / 1.3.4 관측 가능성 16 / 1.3.5 관리 용이성 17
1.4 클라우드 네이티브를 지원하는 문화 및 관행 18
__1.4.1 자동화 19 / 1.4.2 지속적 전달 21 / 1.4.3 데브옵스 22
1.5 클라우드가 최선의 선택인가? 24
__1.5.1 속도 25 / 1.5.2 복원력 26 / 1.5.3 확장성 27 / 1.5.4 비용 27
1.6 클라우드 네이티브 구성 28
__1.6.1 컨테이너 29 / 1.6.2 오케스트레이션 32 / 1.6.3 서버리스 33
1.7 클라우드 네이티브 애플리케이션을 위한 아키텍처 35
__1.7.1 다중 계층에서 마이크로서비스 아키텍처까지 그리고 그 이후 36 / 1.7.2 클라우드 네이티브 애플리케이션을 위한 서비스 기반 아키텍처 38
요약 40

CHAPTER 2 클라우드 네이티브 패턴 및 기술 42
2.1 클라우드 네이티브 개발 원칙: 12요소와 확장 43
__2.1.1 하나의 코드베이스, 하나의 애플리케이션 44 / 2.1.2 API 우선 44 / 2.1.3 의존성 관리 44 / 2.1.4 설계, 빌드, 릴리스, 실행 45 / 2.1.5 설정, 크리덴셜 및 코드 45 / 2.1.6 로그 46 / 2.1.7 일회성 46 / 2.1.8 지원 서비스 47 / 2.1.9 환경 동일성 47 / 2.1.10 관리 프로세스 47 / 2.1.11 포트 바인딩 48 / 2.1.12 상태를 갖지 않는 프로세스 48 / 2.1.13 동시성 49 / 2.1.14 원격 측정 49 / 2.1.15 인증 및 승인 49
2.2 스프링을 사용한 클라우드 네이티브 애플리케이션 구축 50
__2.2.1 스프링 개요 50 / 2.2.2 스프링 부트 애플리케이션 구축 51
2.3 도커를 통한 애플리케이션 컨테이너화 62
__2.3.1 도커 소개: 이미지 및 컨테이너 63 / 2.3.2 컨테이너를 통한 스프링 애플리케이션의 실행 66
2.4 쿠버네티스로 컨테이너 관리 68
__2.4.1 쿠버네티스 소개: 배포, 파드, 서비스 69 / 2.4.2 쿠버네티스에서 스프링 애플리케이션 실행 71
2.5 폴라 북숍: 클라우드 네이티브 애플리케이션 75
__2.5.1 시스템 요구 사항 이해 75 / 2.5.2 프로젝트에서 사용되는 패턴과 기술 78
요약 82

PART II 클라우드 네이티브 개발
CHAPTER 3 클라우드 네이티브 개발 시작 87
3.1 클라우드 네이티브 프로젝트 부트스트래핑 88
__3.1.1 하나의 코드베이스, 하나의 애플리케이션 88 / 3.1.2 그래들과 메이븐의 의존성 관리 90
3.2 임베디드 서버로 작업 92
__3.2.1 실행 가능한 JAR 및 임베디드 서버 93 / 3.2.2 요청당 스레드 모델 이해 95 / 3.2.3 내장 톰캣 설정 97
3.3 스프링 MVC를 이용한 RESTful 애플리케이션 구축 100
__3.3.1 REST API를 먼저, 비즈니스 로직은 그다음 100 / 3.3.2 스프링 MVC를 이용한 REST API 구현 106 / 3.3.3 데이터 유효성 검사 및 오류 처리 109 / 3.3.4 미래 요구 사항을 위해 진화하는 API 114
3.4 스프링 RESTful 애플리케이션 테스트 115
__3.4.1 JUnit 5를 이용한 단위 테스트 117 / 3.4.2 @SpringBootTest를 통한 통합 테스트 119 / 3.4.3 @WebMvcTest를 사용한 REST 컨트롤러의 테스트 122 / 3.4.4 @JsonTest를 사용한 JSON 직렬화 테스트 124
3.5 배포 파이프라인: 빌드 및 테스트 126
__3.5.1 배포 파이프라인의 커밋 단계 이해 127 / 3.5.2 깃허브 액션을 이용한 커밋 단계 구현 129
요약 133

CHAPTER 4 외부화 설정 관리 136
4.1 스프링 설정 : 속성과 프로파일 139
__4.1.1 속성: 설정을 위한 키-값 쌍 140 / 4.1.2 프로파일: 기능 플래그와 설정 그룹 146
4.2 외부화된 구성: 하나의 빌드, 여러 설정 150
__4.2.1 커맨드라인 인수를 통한 애플리케이션 설정 152 / 4.2.2 JVM 시스템 속성을 통해 애플리케이션 구성 152 / 4.2.3 환경 변수를 통해 애플리케이션 구성 153
4.3 스프링 클라우드 컨피그 서버로 중앙식 설정 관리하기 155
__4.3.1 깃을 통한 설정 데이터 저장 158 / 4.3.2 설정 서버 구성 160 / 4.3.3 복원력 높은 설정 서버 생성 164 / 4.3.4 설정 서버 REST API 이해 166
4.4 스프링 클라우드 컨피그 클라이언트로 설정 서버 사용 168
__4.4.1 설정 클라이언트 구축 168 / 4.4.2 내결함성이 높은 설정 클라이언트의 구축 171 / 4.4.3 런타임 시 설정 새로고침 173
요약 176

CHAPTER 5 클라우드에서 데이터 저장과 관리 178
5.1 클라우드 네이티브 시스템을 위한 데이터베이스 179
__5.1.1 클라우드에서의 데이터 서비스 180 / 5.1.2 PostgreSQL을 컨테이너로 실행 183
5.2 스프링 데이터에 대한 데이터 지속성 JDBC 185
__5.2.1 JDBC로 데이터베이스에 연결 187 / 5.2.1 스프링 데이터를 통한 지속성 엔티티 정의 190 / 5.2.3 JDBC 감사 활성화와 설정 195 / 5.2.4 스프링 데이터의 데이터 리포지터리 198
5.3 스프링 및 테스트컨테이너로 데이터 지속성 테스트하기 202
__5.3.1 PostgreSQL을 위한 테스트컨테이너 설정 203 / 5.3.2 @DataJdbcTest 및 테스트컨테이너를 통한 데이터 지속성 테스트 205 / 5.3.3 @SpringBootTest 및 테스트컨테이너를 이용한 통합 테스트 206
5.4 플라이웨이를 통한 프로덕션 환경에서의 데이터베이스 관리 207
__5.4.1 플라이웨이 이해: 데이터베이스 버전 관리 208 / 5.4.2 플라이웨이를 이용한 데이터베이스 스키마 초기화 210 / 5.4.3 플라이웨이를 이용한 데이터베이스 진화 211
요약 213

CHAPTER 6 스프링 부트 컨테이너화 215
6.1 도커에서 컨테이너 이미지로 작업하기 216
__6.1.1 컨테이너 이미지 이해 217 / 6.1.2 도커파일을 통한 이미지 생성 218 / 6.1.3 깃허브 컨테이너 저장소로 이미지 저장 222
6.2 스프링 부트 애플리케이션을 컨테이너 이미지로 패키지 226
__6.2.1 스프링 부트의 컨테이너화를 위한 준비 226 / 6.2.2 도커파일로 스프링 부트 컨테이너화 229 / 6.2.3 프로덕션을 위한 컨테이너 이미지 빌드 231 / 6.2.4 클라우드 네이티브 빌드팩을 이용한 스프링 부트 컨테이너화 237
6.3 도커 컴포즈를 통한 스프링 부트 컨테이너의 관리 242
__6.3.1 도커 컴포즈를 통한 컨테이너 라이프사이클 관리 243 / 6.3.2 스프링 부트 컨테이너 디버깅 244
6.4 배포 파이프라인: 패키지 및 등록 247
__6.4.1 커밋 단계에서 릴리스 후보 빌드 248 / 6.4.2 깃허브 액션을 통한 컨테이너 이미지 등록 249
요약 254

CHAPTER 7 스프링 부트를 위한 쿠버네티스 기초 256
7.1 도커에서 쿠버네티스로의 이동 257
__7.1.1 로컬 쿠버네티스 클러스터 259 / 7.1.2 로컬 클러스터에서 데이터 서비스 관리 261
7.2 스프링 부트를 위한 쿠버네티스 배포 263
__7.2.1 컨테이너에서 파드로 263 / 7.2.2 배포를 통한 파드 제어 264 / 7.2.3 스프링 부트 애플리케이션을 위한 배포 객체 생성 265
7.3 서비스 검색 및 부하 분산 271
__7.3.1 서비스 검색 및 부하 분산의 이해 271 / 7.3.2 클라이언트 측 서비스 검색 및 부하 분산 272 / 7.3.3 서버 측 서비스 검색 및 부하 분산 274 / 7.3.4 쿠버네티스 서비스를 통한 스프링 부트 애플리케이션 노출 276
7.4 확장성과 일회성 279
__7.4.1 일회성을 위한 조건: 빠른 시작 280 / 7.4.2 일회성을 위한 조건: 우아한 종료 280 / 7.4.3 스프링 부트 애플리케이션 확장 283
7.5 틸트를 사용한 로컬 쿠버네티스 개발 286
__7.5.1 틸트를 사용한 내부 개발 루프 286 / 7.5.2 옥탄트를 사용한 쿠버네티스 워크로드 시각화 289
7.6 배포 파이프라인: 쿠버네티스 매니페스트 유효성 검사 292
__7.6.1 커밋 단계에서 쿠버네티스 매니페스트 검증 292 / 7.6.2 깃허브 액션을 통한 쿠버네티스 매니페스트 유효성 검사 자동화 294
요약 295

PART III 클라우드 네이티브 분산 시스템
CHAPTER 8 리액티브 스프링: 복원력과 확장성 299
8.1 리액터와 스프링의 비동기 및 비차단 아키텍처 301
__8.1.1 요청당 스레드에서 이벤트 루프로 302 / 8.1.2 프로젝트 리액터: 모노와 플럭스를 갖는 리액티브 스트림 304 / 8.1.3 스프링 리액티브 스택 이해 306
8.2 스프링 웹플럭스와 스프링 데이터 R2DBC를 갖는 리액티브 서버 307
__8.2.1 스프링 부트를 통한 리액티브 애플리케이션 부트스트래핑 309 / 8.2.2 스프링 데이터 R2DBC를 사용한 리액티브 데이터 지속성 311 / 8.2.3 리액티브 스트림을 이용한 비즈니스 로직 구현 318 / 8.2.4 스프링 웹플럭스로 REST API 노출 321
8.3 스프링 웹 클라이언트를 사용한 리액티브 클라이언트 323
__8.3.1 스프링에서 서비스 간 통신 324 / 8.3.2 데이터 교환 방법에 대한 이해 326 / 8.3.3 웹 클라이언트를 통한 REST 클라이언트 구현 328
8.4 리액티브 스프링을 통한 복원력 높은 애플리케이션 332
__8.4.1 타임아웃 332 / 8.4.2 재시도 336 / 8.4.3 폴백 및 오류 처리 339
8.5 스프링, 리액터, 테스트컨테이너를 이용한 리액티브 애플리케이션의 테스트 341
__8.5.1 모의 웹 서버로 REST 클라이언트 테스트 341 / 8.5.2 @DataR2dbcTest 및 테스트컨테이너를 이용한 데이터 지속성 테스트 344 / 8.5.3 @WebFluxTest를 이용한 REST 컨트롤러 테스트 346
요약 348

CHAPTER 9 API 게이트웨이와 서킷 브레이커 350
9.1 에지 서버와 스프링 클라우드 게이트웨이 352
__9.1.1 스프링 클라우드 게이트웨이를 이용한 에지 서버 부트스트래핑 354 / 9.1.2 경로와 술어의 정의 356 / 9.1.3 필터를 통한 요청 및 응답 처리 360
9.2 스프링 클라우드 서킷 브레이커와 Resilience4J로 내결함성 개선하기 362
__9.2.1 스프링 클라우드 서킷 브레이커를 통한 서킷 브레이커 소개 364 / 9.2.2 Resilience4J 서킷 브레이커 설정 365 / 9.2.3 스프링 웹플럭스를 이용한 폴백 REST API 정의 366 / 9.2.4 서킷 브레이커, 재시도 및 시간 제한의 결합 367
9.3 스프링 클라우드 게이트웨이와 레디스를 통한 요청 사용률 제한 371
__9.3.1 레디스 컨테이너 실행 372 / 9.3.2 스프링과 레디스의 통합 373 / 9.3.3 요청 사용률 제한 설정 374
9.4 레디스를 통한 분산 세션 관리 377
__9.4.1 스프링 세션 데이터 레디스를 통한 세션 처리 378
9.5 쿠버네티스 인그레스를 통한 외부 액세스 관리 382
__9.5.1 인그레스 API와 인그레스 컨트롤러 이해 382 / 9.5.2 인그레스 객체 사용 385
요약 388

CHAPTER 10 이벤트 중심 애플리케이션과 함수 390
10.1 이벤트 중심 아키텍처 392
__10.1.1 이벤트 중심 모델 이해 392 / 10.1.2 발행자/구독자 모델의 사용 393
10.2 메시지 브로커와 래빗MQ 395
__10.2.1 메시징 시스템의 AMQP 이해 396 / 10.2.2 발행/구독 통신을 위한 래빗MQ 사용 397
10.3 스프링 클라우드 함수를 통한 함수 399
__10.3.1 스프링 클라우드 함수의 함수적 패러다임 사용 400 / 10.3.2 함수의 합성 및 통합: REST, 서버리스, 데이터 스트림 406 / 10.3.3 @FunctionalSpringBootTest를 통한 통합 테스트 408
10.4 스프링 클라우드 스트림을 통한 메시지 처리 410
__10.4.1 래빗MQ와의 통합 설정 410 / 10.4.2 함수의 메시지 채널 바인딩 412 / 10.4.3 테스트 바인더를 통한 통합 테스트 419 / 10.4.4 실패에 대한 메시지 복원력 422
10.5 스프링 클라우드 스트림을 통한 메시지 생성 및 소비 423
__10.5.1 이벤트 소비자 구현 및 멱등성 문제 423 / 10.5.2 이벤트 생성자 구현과 원자성 문제 427
요약 433

CHAPTER 11 보안: 인증과 SPA 435
11.1 스프링 보안 기초 436
11.2 키클록을 통한 사용자 계정 관리 441
__11.2.1 보안 영역 정의 443 / 11.2.2 사용자 및 역할 관리 444
11.3 오픈ID 커넥트, JWT 및 키클록을 통한 인증 445
__11.3.1 오픈ID 커넥트를 통한 사용자 인증 446 / 11.3.2 JWT를 통한 사용자 정보 교환 450 / 11.3.3 키클록에서 애플리케이션 등록 452
11.4 스프링 보안 및 오픈ID 커넥트로 사용자 인증 455
__11.4.1 새 의존성 추가 456 / 11.4.2 스프링 보안과 키클록의 통합 설정 457 / 11.4.3 기초적인 스프링 보안 설정 458 / 11.4.4 인증된 사용자 콘텍스트 검사 460 / 11.4.5 스프링 보안 및 키클록에서 사용자 로그아웃 설정 464
11.5 스프링 보안과 SPA 통합 468
__11.5.1 앵귤러 애플리케이션 실행 469 / 11.5.2 인증 흐름 제어 471 / 11.5.3 사이트 간 요청 위조 방지 474
11.6 스프링 보안 및 오픈ID 커넥트 테스트 477
__11.6.1 OIDC 인증 테스트 477 / 11.6.2 CSRF 테스트 479
요약 482

CHAPTER 12 보안: 권한과 감사 484
12.1 스프링 클라우드 게이트웨이와 OAuth2를 통한 권한과 역할 485
__12.1.1 스프링 클라우드 게이트웨이에서 다른 서비스로의 토큰 전달 488 / 12.1.2 토큰 사용자 지정 및 사용자 역할 전파 491
12.2 스프링 보안 및 OAuth2를 통한 API 보호(명령형) 497
__12.2.1 스프링 부트 OAuth2 리소스 서버 보호 497 / 12.2.2 스프링 보안 및 JWT를 통한 역할 기반 접근 제어 501 / 12.2.3 스프링 보안 및 테스트컨테이너를 이용한 OAuth2 테스트 504
12.3 스프링 보안과 OAuth2를 이용한 API 보호(반응형) 511
__12.3.1 스프링 부트 OAuth2 리소스 서버 보호 511 / 12.3.2 스프링 보안 및 테스트컨테이너로 OAuth2 테스트 514
12.4 스프링 보안 및 스프링 데이터로 데이터 보호 및 감사 516
__12.4.1 스프링 보안 및 스프링 데이터 JDBC를 사용한 데이터 감사 517 / 12.4.2 스프링 데이터와 @WithMockUser를 통한 데이터 감사 테스트 520 / 12.4.3 스프링 보안 및 스프링 데이터 R2DBC로 사용자 데이터 보호 522 / 12.4.4 @WithMockUser 및 스프링 데이터 R2DBC를 통한 데이터 감사 및 보호 테스트 526
요약 528

PART IV 프로덕션에서의 클라우드 네이티브CHAPTER 13 관측 가능성 및 모니터링 533
13.1 스프링 부트, 로키 및 플루언트 비트를 사용한 로깅 534
__13.1.1 스프링 부트를 사용한 로깅 535 / 13.1.2 로키, 플루언트 비트, 그라파나로 로그 관리하기 538
13.2 스프링 부트 액추에이터와 쿠버네티스를 사용한 상태 프로브 544
__13.2.1 액추에이터를 통한 스프링 부트 애플리케이션 상태 프로브 정의 545 / 13.2.2 스프링 부트 및 쿠버네티스에서 상태 프로브 설정 548
13.3 스프링 부트 액추에이터, 프로메테우스, 그라파나를 통한 메트릭 및 모니터링 553
__13.3.1 스프링 부트 액추에이터 및 마이크로미터로 메트릭 설정 554 / 13.3.2 프로메테우스와 그라파나를 통한 메트릭 모니터링 557 / 13.3.3 쿠버네티스에서 프로메테우스 메트릭 설정 562
13.4 오픈텔레메트리 및 템포를 사용한 분산 추적 563
__13.4.1 템포와 그라파나를 통한 트레이스 관리 566 / 13.4.2 오픈텔레메트리를 사용해 스프링 부트에서 추적 구성하기 567
13.5 스프링 부트 액추에이터를 통한 애플리케이션 관리 및 모니터링 572
__13.5.1 스프링 부트에서 플라이웨이 마이그레이션 모니터링 573 / 13.5.2 애플리케이션 정보 노출 574 / 13.5.3 힙 덤프 생성 및 분석 577
요약 579

CHAPTER 14 설정과 시크릿 관리 581
14.1 쿠버네티스에서 애플리케이션 설정하기 582
__14.1.1 스프링 시큐리티를 통한 설정 서버 보안 583 / 14.1.2 스프링 클라우드 버스를 통한 런타임 설정 새로고침 584 / 14.1.3 스프링 클라우드 컨피그를 통한 시크릿 관리 586 / 14.1.4 스프링 클라우드 컨피그 비활성화 587
14.2 쿠버네티스에서 컨피그맵과 시크릿 사용 588
__14.2.1 컨피그맵을 통한 스프링 부트 설정 589 / 14.2.2 시크릿으로 민감한 정보를 저장하거나 저장하지 않기 594 / 14.2.3 스프링 클라우드 쿠버네티스를 통한 런타임 설정 갱신 597
14.3 커스터마이즈를 통한 설정 관리 600
__14.3.1 커스터마이즈를 통한 스프링 부트 애플리케이션 관리 및 설정 601 / 14.3.2 커스터마이즈를 통한 여러 환경에 대한 쿠버네티스 설정 관리 606 / 14.3.3 스테이징을 위한 설정 오버레이 정의 609 / 14.3.4 환경 변수 사용자 지정 변경 610 / 14.3.5 컨피그맵 사용자 정의 변경 612 / 14.3.6 이미지 이름 및 버전의 사용자 지정 변경 613 / 14.3.7 복제본 수 사용자 지정 변경 614
요약 618

CHAPTER 15 지속적 전달과 깃옵스 620
15.1 배포 파이프라인: 수락 단계 621
__15.1.1 지속적 배포를 위한 릴리스 후보 버전 지정 621 / 15.1.2 배포 파이프라인 수락 단계의 이해 626 / 15.1.3 깃허브 액션으로 수락 단계 구현 628
15.2 프로덕션을 위한 스프링 부트 설정 631
__15.2.1 프로덕션을 위한 설정 오버레이 정의 632 / 15.2.2 스프링 부트 컨테이너 CPU 및 메모리 설정 638 / 15.2.3 프로덕션 환경에 스프링 부트 배포 644
15.3 배포 파이프라인: 프로덕션 단계 646
__15.3.1 배포 파이프라인의 프로덕션 단계 이해 647 / 15.3.2 깃허브 액션을 통한 프로덕션 단계 구현 647
15.4 깃옵스를 사용한 지속적 배포 654
__15.4.1 아르고 CD로 깃옵스 구현 656 / 15.4.2 종합하기 660
요약 662

CHAPTER 16 서버리스, 그랄VM 및 케이네이티브 664
16.1 스프링 네이티브 및 그랄VM을 사용한 네이티브 이미지 665
__16.1.1 그랄VM과 네이티브 이미지 이해하기 666 / 16.1.2 스프링 네이티브를 통한 그랄VM의 스프링 부트 지원 667 / 16.1.3 스프링 부트 애플리케이션의 네이티브 이미지 컴파일 674
16.2 스프링 클라우드 함수를 사용한 서버리스 애플리케이션 678
__16.2.1 스프링 클라우드 함수를 통한 서버리스 애플리케이션 구축 679 / 16.2.2 배포 파이프라인: 빌드 및 등록 685 / 16.2.3 서버리스 애플리케이션의 클라우드 배포 687
16.3 케이네이티브를 통한 서버리스 애플리케이션 배포 688
__16.3.1 로컬 케이네이티브 플랫폼 구축 689 / 16.3.2 케이네이티브 CLI로 애플리케이션 배포 690 / 16.3.3 케이네이티브 매니페스트를 통한 애플리케이션 배포 692
요약 696

APPENDIX 부록
APPENDIX A 개발 환경 설정 701
A.1 자바 701
A.2 도커 703
A.3 쿠버네티스 705
A.4 다른 툴 707

APPENDIX B 디지털오션 프로덕션 환경을 위한 쿠버네티스 710
B.1 디지털오션에서 쿠버네티스 클러스터 실행 711
B.2 디지털오션에서 PostgresQL 데이터베이스 실행 715
B.3 디지털오션에서 레디스 실행 717
B.4 쿠버네티스 오퍼레이터를 통한 래빗MQ 실행 719
B.5 헬름 차트를 사용한 키클록 실행 720
B.6 폴라 UI 실행 723
B.7 모든 클라우드 리소스 삭제 723

찾아보기 725