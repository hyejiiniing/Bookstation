1장 네트워크 게임의 개요
__1.1 멀티플레이어 게임의 간추린 역사
____1.1.1 로컬 멀티플레이어 게임
____1.1.2 초기 네트워크 멀티플레이어 게임
____1.1.3 MUD: 멀티 유저 던전
____1.1.4 랜 게임
____1.1.5 온라인 게임
____1.1.6 MMO 게임
____1.1.7 모바일 네트워크 게임
__1.2 [스타시즈: 트라이브스]
____1.2.1 플랫폼 패킷 모듈
____1.2.2 연결 관리자
____1.2.3 스트림 관리자
____1.2.4 이벤트 관리자
____1.2.5 고스트 관리자
____1.2.6 이동 관리자
____1.2.7 기타 시스템
__1.3 [에이지 오브 엠파이어]
____1.3.1 턴 타이머
____1.3.2 동기화
__1.4 요약
__1.5 복습 문제
__1.6 더 읽을거리

2장 인터넷
__2.1 패킷 스위칭의 기원
__2.2 TCP/IP 스택의 계층 구조
__2.3 물리 계층
__2.4 링크 계층
____2.4.1 이더넷/802.3
__2.5 네트워크 계층
____2.5.1 IPv4
____2.5.2 IPv6
__2.6 전송 계층
____2.6.1 UDP
____2.6.2 TCP
__2.7 응용 계층
____2.7.1 DHCP
____2.7.2 DNS
__2.8 NAT
____2.8.1 NAT 투과
__2.9 요약
__2.10 복습 문제
__2.11 더 읽을거리

3장 버클리 소켓
__3.1 소켓 만들기
__3.2 운영체제별 API 차이
__3.3 소켓 주소
____3.3.1 자료형 안전성
____3.3.2 문자열로 sockaddr 초기화하기
____3.3.3 소켓 바인딩하기
__3.4 UDP 소켓
____3.4.1 자료형 안전성을 보강한 UDP 소켓
__3.5 TCP 소켓
____3.5.1 연결된 소켓으로 데이터 보내고 받기
____3.5.2 자료형 안전성을 보강한 TCP 소켓
__3.6 블로킹 I/O와 논블로킹 I/O
____3.6.1 멀티스레딩
____3.6.2 논블로킹 I/O
____3.6.3 select( ) 함수
__3.7 소켓 부가 옵션
__3.8 요약
__3.9 복습 문제
__3.10 더 읽을거리

4장 객체 직렬화
__4.1 직렬화가 필요한 이유
__4.2 스트림
____4.2.1 메모리 스트림
____4.2.2 엔디언 호환성
____4.2.3 비트 스트림
__4.3 참조된 데이터 처리
____4.3.1 임베딩(또는 인라이닝)
____4.3.2 링킹
__4.4 압축
____4.4.1 희소 배열(sparse array) 압축
____4.4.2 엔트로피 인코딩
____4.4.3 고정소수점
____4.4.4 기하 압축
__4.5 유지보수성
____4.5.1 직렬화 읽기와 쓰기를 하나로 합치기
____4.5.2 데이터 주도 직렬화
__4.6 요약
__4.7 복습 문제
__4.8 더 읽을거리

5장 객체 리플리케이션
__5.1 월드 상태
__5.2 객체를 리플리케이션하기
____5.2.1 객체 생성 레지스트리
____5.2.2 한 패킷에 여러 객체 실어 보내기
__5.3 초간단 월드 상태 리플리케이션
__5.4 월드 상태의 변경
____5.4.1 객체 상태 부분 리플리케이션
__5.5 직렬화 객체로 RPC 수행
__5.6 리플리케이션 시스템 개조하기
__5.7 요약
__5.8 복습 문제
__5.9 더 읽을거리

6장 네트워크 토폴로지와 예제 게임
__6.1 네트워크 토폴로지
____6.1.1 클라이언트-서버
____6.1.2 피어-투-피어
__6.2 클라이언트-서버 구현하기
____6.2.1 서버 코드와 클라이언트 코드 분리하기
____6.2.2 네트워크 관리자 및 신규 클라이언트 마중하기
____6.2.3 입력 공유 및 클라이언트 프록시
__6.3 피어-투-피어 구현하기
____6.3.1 신규 피어 마중하기 및 게임 시작하기
____6.3.2 명령 공유와 락스텝 턴
____6.3.3 동기화 유지하기
__6.4 요약
__6.5 복습 문제
__6.6 더 읽을거리

7장 레이턴시, 지터링, 신뢰성
__7.1 레이턴시
____7.1.1 네트워크가 원인이 아닌 레이턴시
____7.1.2 네트워크 레이턴시
__7.2 지터링
__7.3 패킷 손실
__7.4 신뢰성: TCP냐 UDP냐
__7.5 패킷 배달 통지
____7.5.1 외부로 나가는 패킷에 꼬리표 달기
____7.5.2 패킷을 받고 확인응답하기
____7.5.3 확인응답 처리 및 배달 여부 알리기
__7.6 객체 리플리케이션 신뢰성
____7.6.1 이미 전송 중인 최신 상태의 재전송을 막아 최적화하기
__7.7 실제와 유사한 환경을 꾸며 테스트하기
__7.8 요약
__7.9 복습 문제
__7.10 더 읽을거리

8장 레이턴시 대응 강화
__8.1 더미 터미널 클라이언트
__8.2 클라이언트 측 보간
__8.3 클라이언트 측 예측
____8.3.1 데드 레커닝
____8.3.2 클라이언트 이동 예측 및 이동 조작 되새김
____8.3.3 레이턴시를 교묘하게 감추기
__8.4 서버 측 되감기
__8.5 요약
__8.6 복습 문제
__8.7 더 읽을거리

9장 규모 확장에 대응하기
__9.1 객체 스코프 내지 연관성
____9.1.1 스태틱 존
____9.1.2 시야 절두체 사용
____9.1.3 기타 가시성 기법
____9.1.4 보이지 않아도 스코프에 포함되어야 하는 경우
__9.2 서버 파티셔닝
__9.3 인스턴싱
__9.4 우선순위와 빈도
__9.5 요약
__9.6 복습 문제
__9.7 더 읽을거리

10장 보안
__10.1 패킷 스니핑
____10.1.1 중간자 공격
____10.1.2 호스트 머신상 패킷 스니핑
__10.2 입력 검증
__10.3 소프트웨어 치트 감지
____10.3.1 VAC
____10.3.2 워든
__10.4 서버 보안
____10.4.1 디도스 공격
____10.4.2 악성 데이터
____10.4.3 소요 시간 분석 공격
____10.4.4 침입
__10.5 요약
__10.6 복습 문제
__10.7 더 읽을거리

11장 상용 엔진 사례
__11.1 언리얼 엔진
____11.1.1 소켓과 기본 네트워킹
____11.1.2 게임 객체와 토폴로지
____11.1.3 액터 리플리케이션
____11.1.4 원격 프로시저 호출
__11.2 유니티
____11.2.1 전송 계층 API
____11.2.2 게임 객체와 토폴로지
____11.2.3 객체 스폰과 리플리케이션
____11.2.4 원격 프로시저 호출
____11.2.5 매치메이킹
__11.3 요약
__11.4 복습 문제
__11.5 더 읽을거리

12장 게임 서비스 플랫폼
__12.1 게임 서비스 플랫폼 선택하기
__12.2 기본 셋업
____12.2.1 초기화, 구동, 마무리
____12.2.2 유저 ID 및 이름
__12.3 로비 및 매치메이킹
__12.4 네트워킹
__12.5 플레이어 통계
__12.6 플레이어 도전과제
__12.7 리더보드
__12.8 기타 서비스
__12.9 요약
__12.10 복습 문제
__12.11 더 읽을거리

13장 클라우드에 전용 서버 호스팅하기
__13.1 클라우드, 꼭 사용해야 할까
__13.2 필수 도구
____13.2.1 REST
____13.2.2 JSON
____13.2.3 Node.js
__13.3 용어 및 개요
____13.3.1 서버 게임 인스턴스
____13.3.2 게임 서버 프로세스
____13.3.3 게임 서버 머신
____13.3.4 하드웨어
__13.4 로컬 서버 프로세스 관리자
____13.4.1 프로세스 모니터링
__13.5 가상 머신 관리자
____13.5.1 가상 머신 모니터링
__13.6 요약
__13.7 복습 문제
__13.8 더 읽을거리

부록 A 모던 C++ 기초
A.1 C+ +11
A.2 레퍼런스
A.2.1 상수 레퍼런스
A.2.2 상수 멤버 함수
A.3 템플릿
A.3.1 템플릿 특수화
A.3.2 정적 단언문과 자료형 특성 정보
A.4 스마트 포인터
A.4.1 shared_ptr
A.4.2 unique_ptr
A.4.3 weak_ptr
A.4.4 주의 사항
A.5 STL 컨테이너
A.6 반복자
A.6.1 범위 기반 for 구문
A.6.2 반복자 활용하기
A.7 더 읽을거리