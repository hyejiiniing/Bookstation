1부. 기초

1장. 소개
1.1 게임 팀 구성
1.2 게임이란?
1.3 게임 엔진이란?
1.4 장르별 게임 엔진
1.5 현존하는 게임 엔진
1.6 런타임 게임 아키텍처
1.7 도구와 자원 파이프라인

2장. 도구
2.1 버전 컨트롤
2.2 컴파일러, 링커, IDE
2.3 프로파일링 툴
2.4 메모리 누수와 오염 감지
2.5 기타 툴

3장. 게임을 위한 소프트웨어 엔지니어링 기초
3.1 C++ 개념과 올바른 사용법
3.2 에러 감지와 처리
3.3 데이터, 코드, 메모리 레이아웃
3.4 컴퓨터 하드웨어 기초
3.5 메모리 구조

4장. 병렬성과 병행 프로그래밍
4.1 병행성과 병렬성에 대한 정의
4.2 묵시적 병렬성
4.3 명시적 병렬성
4.4 운영체제 기초
4.5 병행 프로그래밍 입문
4.6 스레드 동기화 기본 도구
4.7 락 기반 병행성의 문제점
4.8 병행성의 경험적 규칙
4.9 락-프리 병행성
4.10 SIMD/벡터 프로세싱
4.11 GPGPU 프로그래밍에 대한 소개

5장. 게임에 사용되는 3D 수학
5.1 3D 문제를 2D로 풀기
5.2 점과 벡터
5.3 행렬
5.4 사원수
5.5 각 회전 변환 표현 간 비교
5.6 기타 유용한 수학적 개념
5.7 난수 생성

2부. 로우레벨 엔진 시스템

6장. 엔진 지원 시스템
6.1 하부 시스템 시작과 종료
6.2 메모리 관리
6.3 컨테이너
6.4 문자열
6.5 게임 설정

7장. 리소스 시스템과 파일 시스템
7.1 파일 시스템
7.2 리소스 매니저

8장. 게임 루프와 실시간 시뮬레이션
8.1 렌더링 루프
8.2 게임 루프
8.3 게임 루프 구조의 형태
8.4 가상 타임라인
8.5 시간을 측정하는 방법과 처리하는 방법
8.6 멀티프로세서 게임 루프

9장. 휴먼 인터페이스 장치
9.1 휴먼 인터페이스 장치의 종류
9.2 HID와의 인터페이스
9.3 입력의 종류
9.4 출력의 종류
9.5 게임 엔진의 HID 시스템
9.6 휴먼 인터페이스 장치들의 실제

10장. 디버깅과 개발 도구
10.1 로그 기록과 추적
10.2 디버그 정보 그리기 기능
10.3 인게임 메뉴
10.4 인게임 콘솔
10.5 디버그 카메라와 게임 일시 정지
10.6 치트
10.7 스크린샷과 무비 캡처
10.8 인게임 프로파일링
10.9 인게임 메모리 상태와 누수 감지

3부. 그래픽, 모션, 사운드

11장. 렌더링 엔진
11.1 깊이 버퍼를 이용한 삼각형 래스터화의 기초
11.2 렌더링 파이프라인
11.3 고급 조명 기법과 전역 조명
11.4 시각 효과와 오버레이
11.5 더 읽을거리

12장. 애니메이션 시스템
12.1 캐릭터 애니메이션의 종류
12.2 뼈대
12.3 포즈
12.4 클립
12.5 스키닝과 행렬 팔레트 생성
12.6 애니메이션 블렌딩
12.7 후처리
12.8 압축 기법
12.9 애니메이션 파이프라인
12.10 액션 상태 기계
12.11 제약 조건

13장. 충돌과 강체 역학
13.1 정말 게임에 물리가 필요해?
13.2 충돌/물리 미들웨어
13.3 충돌 검출 시스템
13.4 강체 역학
13.5 물리 엔진과 게임 통합
13.6 고급 물리 기능

14장. 오디오
14.1 소리의 물리적 개념
14.2 소리의 수학
14.3 오디오 기술들
14.4 3D 오디오 렌더링
14.5 오디오 엔진 아키텍처
14.6 게임을 위한 오디오 기능들

4부. 게임플레이

15장. 게임플레이 시스템 기초
15.1 게임 월드의 구성
15.2 동적 구성 요소 구현: 게임 객체
15.3 데이터 주도 게임 엔진
15.4 게임 월드 에디터

16장. 런타임 게임플레이 기반 시스템
16.1 게임플레이 기반 시스템의 컴포넌트
16.2 런타임 객체 모델 구조
16.3 월드 덩어리 데이터 형식
16.4 게임 월드의 로딩과 스트리밍
16.5 객체 참조와 월드 질의
16.6 실시간 게임 객체 업데이트
16.7 병행성을 활용한 게임 객체 업데이트
16.8 이벤트와 메시지 전달
16.9 스크립트
16.10 하이레벨 게임 흐름

5부. 결론

17장. 추가 사항
17.1 다루지 않았던 엔진 시스템
17.2 게임플레이 시스템