[01부] 첫 단계

▣ 01장: 오늘날의 보안
1.1 스프링 시큐리티: 개념과 장점
1.2 소프트웨어 보안이란?
1.3 보안이 중요한 이유는 무엇인가?
1.4 웹 애플리케이션의 일반적인 보안 취약성
__1.4.1 인증과 권한 부여의 취약성
__1.4.2 세션 고정이란?
__1.4.3 XSS(교차 사이트 스크립팅)란?
__1.4.4 CSRF(사이트 간 요청 위조)란?
__1.4.5 웹 애플리케이션의 주입 취약성 이해
__1.4.6 민감한 데이터의 노출 처리하기
__1.4.7 메서드 접근 제어 부족이란?
__1.4.8 알려진 취약성이 있는 종속성 이용
1.5 다양한 아키텍처에 적용된 보안
__1.5.1 일체형 웹 애플리케이션 설계
__1.5.2 백엔드/프런트엔드 분리를 위한 보안 설계
__1.5.3 OAuth 2 흐름 이해
__1.5.4 API 키, 암호화 서명, IP 검증을 이용해 요청 보안
1.6 이 책에서 배울 내용
요약

▣ 02장: 안녕! 스프링 시큐리티
2.1 첫 번째 프로젝트 시작
2.2 기본 구성이란?
2.3 기본 구성 재정의
__2.3.1 UserDetailsService 구성 요소 재정의
__2.3.2 엔드포인트 권한 부여 구성 재정의
__2.3.3 다른 방법으로 구성 설정
__2.3.4 AuthenticationProvider 구현 재정의
__2.3.5 프로젝트에 여러 구성 클래스 이용
요약

[02부] 구현

▣ 03장: 사용자 관리
3.1 스프링 시큐리티의 인증 구현
3.2 사용자 기술하기
__3.2.1 UserDetails 계약의 정의 이해하기
__3.2.2 GrantedAuthority 계약 살펴보기
__3.2.3 최소한의 UserDetails 구현 작성
__3.2.4 빌더를 이용해 UserDetails 형식의 인스턴스 만들기
__3.2.5 사용자와 연관된 여러 책임 결합
3.3 스프링 시큐리티가 사용자를 관리하는 방법 지정
__3.3.1 UserDetailsService 계약의 이해
__3.3.2 UserDetailsService 계약 구현
__3.3.3 UserDetailsManager 계약 구현
요약

▣ 04장: 암호 처리
4.1 PasswordEncoder 계약의 이해
__4.1.1 PasswordEncoder 계약의 정의
__4.1.2 PasswordEncoder 계약의 구현
__4.1.3 PasswordEncoder의 제공된 구현 선택
__4.1.4 DelegatingPasswordEncoder를 이용한 여러 인코딩 전략
4.2 스프링 시큐리티 암호화 모듈에 관한 추가 정보
__4.2.1 키 생성기 이용
__4.2.2 암호화와 복호화 작업에 암호기 이용
요약

▣ 05장: 인증 구현
5.1 AuthenticationProvider의 이해
__5.1.1 인증 프로세스 중 요청 나타내기
__5.1.2 맞춤형 인증 논리 구현
__5.1.3 맞춤형 인증 논리 적용
5.2 SecurityContext 이용
__5.2.1 보안 컨텍스트를 위한 보유 전략 이용
__5.2.2 비동기 호출을 위한 보유 전략 이용
__5.2.3 독립형 애플리케이션을 위한 보유 전략 이용
__5.2.4 DelegatingSecurityContextRunnable로 보안 컨텍스트 전달
__5.2.5 DelegatingSecurityContextExecutorServi
보안 컨텍스트 전달
5.3 HTTP Basic 인증과 양식 기반 로그인 인증 이해하기
__5.3.1 HTTP Basic 이용 및 구성
__5.3.2 양식 기반 로그인으로 인증 구현
요약

▣ 06장: 실전 - 작고 안전한 웹 애플리케이션
6.1 프로젝트 요구 사항과 설정
6.2 사용자 관리 구현
6.3 맞춤형 인증 논리 구현
6.4 주 페이지 구현
6.5 애플리케이션 실행 및 테스트
요약

▣ 07장: 권한 부여 구성 - 액세스 제한
7.1 권한과 역할에 따라 접근 제한
__7.1.1 사용자 권한을 기준으로 모든 엔드포인트에 접근 제한
__7.1.2 사용자 역할을 기준으로 모든 엔드포인트에 대한 접근을 제한
__7.1.3 모든 엔드포인트에 대한 접근 제한
요약

▣ 08장: 권한 부여 구성 - 제한 적용
8.1 선택기 메서드로 엔드포인트 선택
8.2 MVC 선택기로 권한을 부여할 요청 선택
8.3 앤트 선택기로 권한을 부여할 요청 선택
8.4 정규식 선택기로 권한을 부여할 요청 선택
요약

▣ 09장: 필터 구현
9.1 스프링 시큐리티 아키텍처의 필터 구현
9.2 체인에서 기존 필터 앞에 필터 추가
9.3 체인에서 기존 필터 뒤에 필터 추가
9.4 필터 체인의 다른 필터 위치에 필터 추가
9.5 스프링 시큐리티가 제공하는 필터 구현
요약

▣ 10장: CSRF 보호와 CORS 적용
10.1 애플리케이션에 CSRF(사이트 간 요청 위조) 보호 적용
__10.1.1 스프링 시큐리티의 CSRF 보호가 작동하는 방식
__10.1.2 실제 시나리오에서 CSRF 보호 사용
__10.1.3 CSRF 보호 맞춤 구성
10.2 CORS(교차 출처 리소스 공유) 이용
__10.2.1 CORS 작동 방식
__10.2.2 @CrossOrigin 어노테이션으로 CORS 정책 적용
__10.2.3 CorsConfigurer로 CORS 적용
요약

▣ 11장 실전 - 책임의 분리
11.1 예제의 시나리오와 요구 사항
11.2 토큰의 구현과 이용
__11.2.1 토큰이란?
__11.2.2 JSON 웹 토큰이란?
11.3 인증 서버 구현
11.4 비즈니스 논리 서버 구현
__11.4.1 Authentication 객체 구현
__11.4.2 인증 서버에 대한 프락시 구현
__11.4.3 AuthenticationProvider 인터페이스 구현
__11.4.4 필터 구현
__11.4.5 보안 구성 작성
__11.4.6 전체 시스템 테스트
요약

▣ 12장: OAuth 2가 작동하는 방법
12.1 OAuth 2 프레임워크
12.2 OAuth 2 인증 아키텍처의 구성 요소
12.3 OAuth 2를 구현하는 방법 선택
__12.3.1 승인 코드 그랜트 유형의 구현
__12.3.2 암호 그랜트 유형 구현
__12.3.3 클라이언트 자격 증명 그랜트 유형 구현
__12.3.4 갱신 토큰으로 새 액세스 토큰 얻기
12.4 OAuth 2의 허점
12.5 간단한 SSO(Single Sign-On) 애플리케이션 구현
__12.5.1 권한 부여 서버 관리
__12.5.2 구현 시작
__12.5.3 ClientRegistration 구현
__12.5.4 ClientRegistrationRepository 구현
__12.5.5 스프링 부트 구성의 순수한 마법
__12.5.6 인증된 사용자의 세부 정보 얻기
__12.5.7 애플리케이션 테스트
요약

▣ 13장: OAuth 2 - 권한 부여 서버 구현
13.1 맞춤형 권한 부여 서버 구현 작성
13.2 사용자 관리 정의
13.3 권한 부여 서버에 클라이언트 등록
13.4 암호 그랜트 유형 이용
13.5 승인 코드 그랜트 유형 이용
13.6 클라이언트 자격 증명 그랜트 유형 이용
13.7 갱신 토큰 그랜트 유형 이용
요약

▣ 14장: OAuth 2 - 리소스 서버 구현
14.1 리소스 서버 구현
14.2 원격으로 토큰 확인
14.3 JdbcTokenStore로 데이터베이스 참조 구현
14.4 방식의 간단한 비교
요약

▣ 15장 OAuth 2 - JWT와 암호화 서명 사용
15.1 JWT의 대칭 키로 서명된 토큰 이용
15.1.1 JWT 이용
__15.1.2 JWT를 발행하는 권한 부여 서버 구현
__15.1.3 JWT를 이용하는 리소스 서버 구현
15.2 JWT를 이용한 비대칭 키로 서명된 토큰 이용
__15.2.1 키 쌍 생성
__15.2.2 비밀 키를 이용하는 권한 부여 서버 구성
__15.2.3 공개 키를 이용하는 리소스 서버 구현
__15.2.4 공개 키를 노출하는 엔드포인트 이용
15.3 JWT에 맞춤형 세부 정보 추가
__15.3.1 토큰에 맞춤형 세부 정보를 추가하도록 권한 부여 서버 구성
__15.3.2 JWT의 맞춤형 세부 정보를 읽을 수 있게 리소스 서버 구성
요약

▣ 16장: 전역 메서드 보안 - 사전 및 사후 권한 부여
16.1 전역 메서드 보안 활성화
__16.1.1 호출 권한 부여의 이해
__16.1.2 프로젝트에서 전역 메서드 보안 활성화
16.2 권한과 역할에 사전 권한 부여 적용
16.3 사후 권한 부여 적용
16.4 메서드의 사용 권한 구현
요약

▣ 17장: 전역 메서드 보안 - 사전 및 사후 필터링
17.1 메서드 권한 부여를 위한 사전 필터링 적용
17.2 메서드 권한 부여를 위한 사후 필터링 적용
17.3 스프링 데이터 리포지토리에 필터링 이용
요약

▣ 18장 실전 - OAuth 2 애플리케이션
18.1 애플리케이션 시나리오
18.2 Keycloak을 권한 부여 서버로 구성
__18.2.1 시스템에 클라이언트 등록
__18.2.2 클라이언트 범위 지정
__18.2.3 사용자 추가 및 액세스 토큰 얻기
__18.2.4 사용자 역할 정의
18.3 리소스 서버 구현
18.4 애플리케이션 테스트
__18.4.1 사용자가 자기 레코드만 추가할 수 있는지 증명
__18.4.2 사용자가 자기 레코드만 가져올 수 있는지 증명
__18.4.3 관리자만 레코드를 삭제할 수 있는지 증명
요약

▣ 19장: 리액티브 앱을 위한 스프링 시큐리티
19.1 리액티브 앱이란?
19.2 리액티브 앱에서의 사용자 관리
19.3 리액티브 앱에서 권한 부여 규칙 구성
__19.3.1 리액티브 앱의 엔드포인트 계층에 권한 부여 적용
__19.3.2 리액티브 앱에 메서드 보안 적용
19.4 리액티브 앱과 OAuth 2
요약

▣ 20장: 스프링 시큐리티 테스트
20.1 모의 사용자로 테스트
20.2 UserDetailsService의 사용자로 테스트
20.3 맞춤형 인증 Authentication 객체를 이용한 테스트
20.4 메서드 보안 테스트
20.5 인증 테스트
20.6 CSRF 구성 테스트
20.7 CORS 구성 테스트
20.8 리액티브 스프링 시큐리티 구현 테스트
요약

▣ 부록A: 스프링 부트 프로젝트 만들기
A.1 start.spring.io로 프로젝트 만들기
A.2 STS(스프링 툴 스위트)로 프로젝트 만들기